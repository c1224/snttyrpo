#!/usr/bin/perl -w
=head


get_paths
функция возвращает список файлов и директорий в алфавитном порядке,
в той очередности, в которой они будут выводится в дереве.
для каждого уровня вложенности сначала идут директории, потом файлы.

возвращает список вида:

/dir/dir1/file1
/dir/dir1/file2
/dir/dir2/file1
/dir/file1
/dir/file2
/dir/file3

1. открывается директория
2. если открылась, она добавляется в массив @paths
3. из того, что внутри открывшейся директории:
    3.1 . и .. не обрабатываются
    3.2 все директории добавляются в @new_dirs
    3.3 все не директории (файлы) добавляются в @paths_f
4. если в директории были другие директории,
   то они сортируются, добавляются в общий @paths
5. для каждой из них выполняется п.1-4.
6. таким образом, пока в главной директории будут другие
   директории, то программа будет их открывать до последней
   пока что не обращая внимания на файлы и другие директории
7. если в какой-то директории закончились другие вложенные
   директории, то к общему @paths добавляются @paths_f,
   то есть файлы в последней (самой младшей) директории.

print_level_tree
1. от каждого пути отрезается корневая директория (ну просто)
2. для каждого пути определяется уровень вложенности
   конечного файла/директории.
   (чем он больше, тем файл/директория "младше")
3. каждый элемент режется по слэшу, сохраняя все более
   старшие директории (нужно для отступов).
4. для каждого пути определяется то, то стоит слева от слэша
   конечного файла/директории.
   т.е. его ../ (нужно для рисования соединительных палочек)
5. (сам конечный файл - это $parts[-1]).
6. если файл на 1 младше, чем предыдущий, то он печатается
   в той же строке.
7. если нет (того же старшинства, или старше),
   то делается отступ длиной в корневую директорию,
   затем печатается трехсимвольная палочка,
   затем делаются отступы длиной в каждый из @parts пути,
   и после каждого из @parts тоже печатается трехсимвольная
   палочка, кроме $parts[-1].
8. наконец печатается $parts[-1];

fcon
case 1:
палочки, которые рисуются после первого отступа длиной
в корневой каталог.
1. если сразу же за ними стоит элемент то рисует ├─,
   в случае, если файл этого уровня старшенства не последний,
   и └─, если последний.
2. если сразу же за ними нет элементов (т.е. идет отступ),
   рисуется │, в случае, если ниже еще есть элемент такого же
   уровня старшинства, или тройной пробел, если нет.   

case 2:
палочки, которые рисуются в случае, если элемент печатается в
той же строке, что и предыдущий (сразу же за ним).
1. если следующий за ним элемент более высокого старшинства 
   имеет того же предка, что и рассматриваемый элемент,
   то рисуется ─┬─, иначе ───.

case3:
палочки, которые рисуются перед элементом строки уже имеющим
"братьев" одинаковый уровень старшинства.
1. если следующий за ним немладший элемент имеет такое же старшинство,
   то рисуется ├─, если старше то рисуется └─.

case 10:
палочки, которые рисуются между пробельными вставками, когда
за и перед ними нет никаких элементов.
1. если следующий за текущим элементом (за тем, который стоит
   первым справа от рисуемых здесь палочек) имеет старшинство
   того же уровня, сколько уже напечатано пробельных диапазонов, 
   то рисуется │, иначе тройной пробел.


=cut








use strict;
use Switch;

my $dir = $ARGV[0];

$dir = $ENV{'PWD'} if length $dir == 0;
$dir =~ s/\/$// if length $dir > 1;


sub get_paths {
    my $path = $_[0];
    my @paths, my @new_dirs, my @paths_f;

    opendir (my $dh, $path) or print "ERROR open dir $path\n";
    push @paths, $path; #here goes a directory
    while (readdir $dh) {
        if ($_ eq '.' or $_ eq '..') {next;}
        if (!-d "$path/$_") {push (@paths_f, "$path/$_");} #here goes a file
        else {
            push (@new_dirs, "$path/$_");
        };
    }
 
    if (@new_dirs > 0) {
        foreach (sort @new_dirs) {push @paths, get_paths($_);}
    }   

    push (@paths, sort @paths_f);
    
    return @paths; 
}


sub fcon {
    my @elderof = @{$_[0]};
    my @levelof = @{$_[1]};
    my $i = $_[2];
    my $case = $_[3];
    my $imax = $_[4];
    my $iter = $_[5];
    
    switch ($case) {
    
        case 1 { if ($levelof[$i] == 1) {
                     for (my $j=$i+1; $j<$imax; $j++) {
                         if ($levelof[$j] == 1) {
                             return " ├─";
                         }
                     }

                 return " └─";
                 }
                 
                 for (my $j=$i+1; $j<$imax; $j++) {
                     if ($levelof[$j] == 1) {
                         return " │ ";
                     }
                 }
                 return "   ";
               }
        
        case 10 { for (my $j=$i+1; $j<$imax; $j++) {
                      if ($levelof[$i] > $levelof[$j]) {
                          if ($levelof[$j] < $iter) {return "   ";}
                          if ($iter == $levelof[$j]) {return " │ ";}
                         # next;
                      } 
                  }
                  return "   "; 
                }
    
        case 2 { #if (not defined $levelof[$i+1]) {return "───";}
                 #if ($levelof[$i] > $levelof[$i+1]) {return "───";} 
                 #else {
                     for (my $j=$i+1; $j<$imax; $j++) {
                         if ($levelof[$i] > $levelof[$j]) {return "───";}
                         if (($elderof[$i] eq $elderof[$j])and($levelof[$i] == $levelof[$j])) { 
                             return "─┬─";
                         }
                     }
                     return "───";
                 #}
               }
     
        case 3 { #if ($levelof[$i] == $levelof[$i+1]) {
                 #    return " ├─";
                 #}
                 #else {
                     for (my $j=$i+1; $j<$imax; $j++) {
                         if ($levelof[$i] == $levelof[$j]) {return " ├─";}
                         if ($levelof[$i] > $levelof[$j]) {return " └─";}
                     }        
                 return " └─";
                 #}
               }
        case 4 { return "---"; }
    }
}

sub print_level_tree {
    
    my @levelof;    # сохраняет для всех файлов их уровень вложенности, после каждого "/" повышается на 1.
    $levelof[0] = 0;
    $levelof[@_+0] = 0;

    my @elderof;    # elder - родитель файла, который находится на 1 "/" выше. нужно для расстановки палочек.
    $elderof[0] = 0;

    for (my $i=1; $i<@_+0; $i++) {
        $_[$i] = (split/$dir/,$_[$i])[-1];
        $levelof[$i] = (split/\//,$_[$i])-1;
        $elderof[$i] = (split/\//,$_[$i])[-2];
    }

    print $dir;
    for (my $i=1; $i<@_+0; $i++) {
        my @parts = split/\//, $_[$i];
        shift @parts;
         
        if ($levelof[$i] - $levelof[$i-1] == 1) {
            
            print fcon(\@elderof,\@levelof,$i,2,@_+0);
            print "$parts[-1]";
            next;
        } 

        else {   
            print "\n";
            print " " x length($dir);
            print fcon(\@elderof,\@levelof,$i,1,@_+0);      
   
            for (my $j=0; $j<@parts-1; $j++) {
                print " " x length($parts[$j]);
                if ($j==@parts-2) {print fcon(\@elderof,\@levelof,$i,3,@_+0);}
                else {print fcon(\@elderof,\@levelof,$i,10,@_+0,$j+2);}
            }
            
            print "$parts[-1]";
        }
    }
    print "\n";
        
}


my @paths = get_paths($dir);

print "$_\n" foreach @paths;

print "\n";
print_level_tree(@paths);
